| Lili Language.

@id id
@int integer
@byte byte_integer
@short short_integer
@long long_integer
@float real
@double double_real
@str string
@chr character


@key not cmpl copy len mod equals and or xor band bor bxor

@key package get const fn typename struct datatype classtype instance of local

@key common private protected

@key let var in when where by

@key if then else select case match

@key auto new delete

@key for do while break continue return

@key int char short long unsigned float double boolean void

@key true false cons null nullptr default this


@op + - * /

@op == < <= > >= !=

@op = += -= *= /= &= ++ -- ** //

@op ( ) [ ] { } . .. , : ; `

@op -> << >> >>> ~ ^ % # ? !


@eof $


@var Program

@var Dotname IDList

@var Name NameList Declaration DeclarationList

@var Type TypeList Type0List

@var Type0 Type1 Type2 PolyType

@var AL Definition DefinitionList

@var DataConstructor DataConstructorList

@var ClassDefinition ClassDefinitionList InstanceDefinition InstanceDefinitionList

@var Operator Operand

@var Expr ExprList

@var Expr0 Expr1 Expr2 Expr3 Expr4 Expr5 Expr6 Expr7 Expr8 Expr9

@var ListExpr ListExprList Generator GeneratorList

@var Case CaseList

@var Pattern BasePattern BasePatternList SubPatternList

@var Statement Block CaseStatement CaseBlock


Program :: DefinitionList $

Dotname :: id
Dotname :: id . Dotname

IDList :: id
IDList :: id IDList

Name :: .
Name :: id
Name :: . [ Type ]
Name :: id [ Type ]

NameList :: Name
NameList :: Name NameList

DeclarationList :: Declaration
DeclarationList :: Declaration , DeclarationList

Declaration :: NameList = Expr
Declaration :: fn id BasePatternList = Expr

Type0 :: int
Type0 :: char
Type0 :: short
Type0 :: long
Type0 :: unsigned int
Type0 :: unsigned char
Type0 :: unsigned short
Type0 :: unsigned long
Type0 :: float
Type0 :: double
Type0 :: boolean
Type0 :: void

|Type0 :: [ Type ]
Type0 :: Type0 [ ]

Type0 :: Type0 ~
Type0 :: Type0 const ~

Type0 :: Type0 %
Type0 :: Type0 const %

Type0 :: Dotname

Type0 :: ( )
Type0 :: ( Type )
Type0 :: ( Type , TypeList )

Type0 :: ( struct NameList )

TypeList :: Type
TypeList :: Type , TypeList

Type0List :: Type0
Type0List :: Type0 Type0List

Type1 :: Type0
Type1 :: Type1 Type0

Type2 :: Type1
Type2 :: Type1 -> Type2

Type :: Type2

PolyType :: Type
PolyType :: { IDList } Type

DefinitionList :: Definition
DefinitionList :: Definition DefinitionList

AL ::
AL :: private
AL :: common
AL :: protected
AL :: common protected

Definition :: ;

Definition :: package Dotname ;

Definition :: package Dotname { DefinitionList }
Definition :: common package Dotname { DefinitionList }
Definition :: private package Dotname { DefinitionList }

Definition :: get Dotname ;
Definition :: get Dotname IDList ;
Definition :: get Dotname * ;

Definition :: [ AL id : PolyType ]

Definition :: AL id = Expr ;
Definition :: AL id [ Type ] = Expr ;

Definition :: AL const id = Expr ;
Definition :: AL const id [ Type ] = Expr ;

Definition :: AL fn id BasePatternList = Expr ;
Definition :: AL fn [ Type ] id BasePatternList = Expr ;

Definition :: AL fn id BasePatternList { Block }
Definition :: AL fn [ Type ] id BasePatternList { Block }

Definition :: AL typename id : Type ;
Definition :: AL typename id IDList : Type ;

Definition :: AL datatype id : DataConstructorList ;
Definition :: AL datatype id IDList : DataConstructorList ;

DataConstructorList :: DataConstructor
DataConstructorList :: DataConstructor , DataConstructorList

DataConstructor :: id
DataConstructor :: id Type0
DataConstructor :: id Type0 Type0List

Definition :: AL classtype id { ClassDefinitionList }
Definition :: AL classtype id IDList { ClassDefinitionList }

Definition :: AL instance id of Type { InstanceDefinitionList }
Definition :: AL instance id BasePatternList of Type { InstanceDefinitionList }

ClassDefinitionList :: ClassDefinition
ClassDefinitionList :: ClassDefinition ClassDefinitionList

ClassDefinition :: [ id : PolyType ]
ClassDefinition :: [ ( Operator Type0 ) : Type ]
ClassDefinition :: [ ( Type0 Operator Type0 ) : Type ]

InstanceDefinitionList :: InstanceDefinition
InstanceDefinitionList :: InstanceDefinition InstanceDefinitionList

InstanceDefinition :: [ id : PolyType ]
InstanceDefinition :: [ ( Operator Type0 ) : Type ]
InstanceDefinition :: [ ( Type0 Operator Type0 ) : Type ]

InstanceDefinition :: ;

InstanceDefinition :: id = Expr ;
InstanceDefinition :: id [ Type ] = Expr ;

InstanceDefinition :: const id = Expr ;
InstanceDefinition :: const id [ Type ] = Expr ;

InstanceDefinition :: fn id BasePatternList = Expr ;
InstanceDefinition :: fn [ Type ] id BasePatternList = Expr ;

InstanceDefinition :: fn ( Operator Operand ) = Expr ;
InstanceDefinition :: fn [ Type ] ( Operator Operand ) = Expr ;

InstanceDefinition :: fn ( Operand Operator Operand ) = Expr ;
InstanceDefinition :: fn [ Type ] ( Operand Operator Operand ) = Expr ;

InstanceDefinition :: fn id BasePatternList { Block }
InstanceDefinition :: fn [ Type ] id BasePatternList { Block }

InstanceDefinition :: fn ( Operator Operand ) { Block }
InstanceDefinition :: fn [ Type ] ( Operator Operand ) { Block }

InstanceDefinition :: fn ( Operand Operator Operand ) { Block }
InstanceDefinition :: fn [ Type ] ( Operand Operator Operand ) { Block }

InstanceDefinition :: local id = Expr ;
InstanceDefinition :: local id [ Type ] = Expr ;

InstanceDefinition :: local const id = Expr ;
InstanceDefinition :: local const id [ Type ] = Expr ;

InstanceDefinition :: local fn id BasePatternList = Expr ;
InstanceDefinition :: local fn [ Type ] id BasePatternList = Expr ;

InstanceDefinition :: local fn ( Operator Operand ) = Expr ;
InstanceDefinition :: local fn [ Type ] ( Operator Operand ) = Expr ;

InstanceDefinition :: local fn ( Operand Operator Operand ) = Expr ;
InstanceDefinition :: local fn [ Type ] ( Operand Operator Operand ) = Expr ;

InstanceDefinition :: local fn id BasePatternList { Block }
InstanceDefinition :: local fn [ Type ] id BasePatternList { Block }

InstanceDefinition :: local fn ( Operator Operand ) { Block }
InstanceDefinition :: local fn [ Type ] ( Operator Operand ) { Block }

InstanceDefinition :: local fn ( Operand Operator Operand ) { Block }
InstanceDefinition :: local fn [ Type ] ( Operand Operator Operand ) { Block }

InstanceDefinition :: let DeclarationList ;
InstanceDefinition :: var DeclarationList ;

InstanceDefinition :: auto let DeclarationList ;
InstanceDefinition :: auto var DeclarationList ;

InstanceDefinition :: cons { Block }
InstanceDefinition :: copy { Block }

Expr0 :: Dotname

Expr0 :: integer
Expr0 :: real
Expr0 :: double_real
Expr0 :: string
Expr0 :: character

Expr0 :: true
Expr0 :: false

Expr0 :: cons
Expr0 :: null
Expr0 :: nullptr

Expr0 :: this

Expr0 :: default

Expr0 :: Expr0 : id
Expr0 :: Expr0 # id
Expr0 :: Expr0 # integer
Expr0 :: Expr0 { TypeList }

Expr0 :: ( )
Expr0 :: ( Expr )
Expr0 :: ( Expr , ExprList )
Expr0 :: ( Expr where DeclarationList )

ExprList :: Expr
ExprList :: Expr , ExprList

Expr0 :: [ ]
Expr0 :: [ ListExpr ]
Expr0 :: [ ListExpr , ListExprList ]
Expr0 :: [ Expr where GeneratorList ]

ListExpr :: Expr
ListExpr :: Expr .. Expr
ListExpr :: Expr .. Expr by Expr
ListExpr :: Expr -> Expr
ListExpr :: Expr -> Expr by Expr

ListExprList :: ListExpr
ListExprList :: ListExpr , ListExprList

Generator :: NameList : Expr
Generator :: NameList : Expr when Expr
Generator :: NameList : [ Expr ; Expr ; Expr ]
Generator :: NameList : [ Expr ; Expr ; Expr ] when Expr

GeneratorList :: Generator
GeneratorList :: Generator , GeneratorList

Expr0 :: new ( )
Expr0 :: new ( Type )
Expr0 :: new ( Type * Expr )
Expr0 :: new ( * Expr )

Expr0 :: new ~ ( Type * Expr )
Expr0 :: new ~ ( * Expr )

Expr1 :: Expr0
Expr1 :: Expr1 Expr0

Expr2 :: Expr1
Expr2 :: - Expr2
Expr2 :: % Expr2
Expr2 :: not Expr2
Expr2 :: cmpl Expr2
Expr2 :: len Expr2
Expr2 :: copy Expr2

Expr3 :: Expr2
Expr3 :: Expr3 ~ Expr2

Expr4 :: Expr3
Expr4 :: Expr4 * Expr3
Expr4 :: Expr4 / Expr3
Expr4 :: Expr4 ** Expr3
Expr4 :: Expr4 // Expr3
Expr4 :: Expr4 mod Expr3

Expr5 :: Expr4
Expr5 :: Expr5 + Expr4
Expr5 :: Expr5 - Expr4
Expr5 :: Expr5 ++ Expr4
Expr5 :: Expr5 -- Expr4

Expr6 :: Expr5
Expr6 :: Expr6 << Expr5
Expr6 :: Expr6 >> Expr5
Expr6 :: Expr6 >>> Expr5

Expr7 :: Expr6
Expr7 :: Expr7 band Expr6
Expr7 :: Expr7 bor Expr6
Expr7 :: Expr7 bxor Expr6

Expr8 :: Expr7
Expr8 :: Expr8 == Expr7
Expr8 :: Expr8 != Expr7
Expr8 :: Expr8 < Expr7
Expr8 :: Expr8 > Expr7
Expr8 :: Expr8 <= Expr7
Expr8 :: Expr8 >= Expr7
Expr8 :: Expr8 equals Expr7

Expr9 :: Expr8
Expr9 :: Expr9 or Expr8
Expr9 :: Expr9 and Expr8

Expr :: Expr9

Expr :: if Expr then Expr else Expr

Expr :: select Expr in { CaseList }

Expr :: fn BasePatternList -> Expr
Expr :: fn [ Type ] BasePatternList -> Expr

Expr :: fn id / BasePatternList -> Expr
Expr :: fn [ Type ] id / BasePatternList -> Expr

Expr :: let DeclarationList in Expr

Expr :: let id / DeclarationList in Expr

CaseList :: Case
CaseList :: Case ;
CaseList :: Case ; CaseList

Case :: case Expr -> Expr
Case :: match BasePatternList -> Expr
Case :: else Expr
Case :: default Expr

Pattern :: id

Pattern :: integer
Pattern :: real
Pattern :: double_real
Pattern :: string
Pattern :: character

Pattern :: true
Pattern :: false

Pattern :: cons
Pattern :: null
Pattern :: nullptr

Pattern :: id BasePatternList
Pattern :: cons BasePatternList

Pattern :: [ ]
Pattern :: [ BasePattern ]
Pattern :: [ BasePattern , SubPatternList ]

BasePatternList :: BasePattern
BasePatternList :: BasePattern BasePatternList

BasePattern :: .
BasePattern :: id
BasePattern :: . [ Type ]
BasePattern :: id [ Type ]

BasePattern :: ( )
BasePattern :: ( Pattern )
BasePattern :: ( BasePattern , SubPatternList )

SubPatternList :: BasePattern
SubPatternList :: BasePattern , SubPatternList

Block ::
Block :: Statement Block

Statement :: ;

Statement :: ` id ` Statement

Statement :: { Block }

Statement :: let DeclarationList ;
Statement :: var DeclarationList ;

Statement :: auto let DeclarationList ;
Statement :: auto var DeclarationList ;

Statement :: fn id BasePatternList = Expr ;
Statement :: fn [ Type ] id BasePatternList = Expr ;

Statement :: fn id BasePatternList { Block }
Statement :: fn [ Type ] id BasePatternList { Block }

Statement :: Expr1 ;

Statement :: Expr0 = Expr ;
Statement :: Expr0 += Expr ;
Statement :: Expr0 -= Expr ;
Statement :: Expr0 *= Expr ;
Statement :: Expr0 /= Expr ;

Statement :: ++ Expr0 ;
Statement :: -- Expr0 ;

Statement :: Expr0 ++ ;
Statement :: Expr0 -- ;

Statement :: % Expr2 = Expr ;
Statement :: % Expr2 += Expr ;
Statement :: % Expr2 -= Expr ;
Statement :: % Expr2 *= Expr ;
Statement :: % Expr2 /= Expr ;

Statement :: ++ % Expr2 ;
Statement :: -- % Expr2 ;

Statement :: % Expr2 ++ ;
Statement :: % Expr2 -- ;

Statement :: Expr3 ~ Expr2 = Expr ;
Statement :: Expr3 ~ Expr2 += Expr ;
Statement :: Expr3 ~ Expr2 -= Expr ;
Statement :: Expr3 ~ Expr2 *= Expr ;
Statement :: Expr3 ~ Expr2 /= Expr ;

Statement :: ++ Expr3 ~ Expr2 ;
Statement :: -- Expr3 ~ Expr2 ;

Statement :: Expr3 ~ Expr2 ++ ;
Statement :: Expr3 ~ Expr2 -- ;

Statement :: if Expr then Statement
Statement :: else Statement

Statement :: select Expr in { CaseBlock }

Statement :: for GeneratorList do Statement

Statement :: while Expr do Statement
Statement :: do Statement while Expr ;

Statement :: break ;
Statement :: break id ;

Statement :: continue ;
Statement :: continue id ;

Statement :: return ;
Statement :: return Expr ;

Statement :: delete Expr ;

CaseBlock ::
CaseBlock :: CaseStatement CaseBlock

CaseStatement :: case Expr -> Statement
CaseStatement :: match BasePatternList -> Statement
CaseStatement :: else Statement
CaseStatement :: default Statement

Operand :: this
Operand :: BasePattern

Operator :: ~
Operator :: %
Operator :: not
Operator :: cmpl
Operator :: len
Operator :: +
Operator :: -
Operator :: *
Operator :: /
Operator :: --
Operator :: //
Operator :: mod
Operator :: <
Operator :: >
Operator :: <<
Operator :: >>
Operator :: >>>
Operator :: <=
Operator :: >=
Operator :: and
Operator :: or
Operator :: band
Operator :: bor
Operator :: bxor





|Statement :: id = Expr ;
|Statement :: id += Expr ;
|Statement :: id -= Expr ;
|Statement :: id *= Expr ;
|Statement :: id /= Expr ;

|Statement :: ++ id ;
|Statement :: -- id ;

|Statement :: id ++ ;
|Statement :: id -- ;

|Statement :: id # StructPath = Expr ;
|Statement :: id # StructPath += Expr ;
|Statement :: id # StructPath -= Expr ;
|Statement :: id # StructPath *= Expr ;
|Statement :: id # StructPath /= Expr ;

|Statement :: ++ id # StructPath ;
|Statement :: -- id # StructPath ;

|Statement :: id # StructPath ++ ;
|Statement :: id # StructPath -- ;
